
## Bit Manipulation Basics (비트 조작 기초)

#### Bit란?

- **비트**는 데이터의 가장 작은 단위로, `0` 또는 `1` 중 하나의 값을 가질 수 있다
- 컴퓨터에서 모든 데이터는 비트로 표현되며, 전기 신호의 상태 (`On/Off` 또는 `True/False`)로 비트를 나타낸다

#### Bit vs Byte

- 바이트는 8개의 비트로 이루어진 단위이다
- 프로그래밍 언어에서 데이터는 일반적으로 바이트를 기준으로 다룬다
- 바이트는 메모리나 저장공간을 할당하고 데이터를 처리할때의 가장 기본적인 단위이다
- 예시:
    - `int`는 보통 4바이트 또는 8바이트
    - `string`은 문자 하나당 보통 2바이트 또는 1바이트
    - `boolean`은 보통 1바이트

#### Bit 조작 이란?

비트 조작은 컴퓨터 프로그래밍에서 가장 low-level의 데이터 조작 기술이다.

- 데이터를 비트(0과 1) 수준에서 직접 다루는 것을 의미, 즉 데이터를 일반적인 바이트 단위가 아닌 비트 단위로 쪼개서 처리하고 조작하는것
- 이를 통해 데이터의 작은 부분을 효율적으로 다루고, 특정 비트 위치를 변경하거나 확인할 수 있다

#### 왜 알아야 하나

- **성능 최적화**: 비트 연산은 CPU에서 직접 처리되어 매우 빠르다
- **메모리 효율성**: 적은 메모리로 많은 정보를 저장할 수 있다
- **특정 문제 해결**: 일부 알고리즘 문제는 비트 연산으로 훨씬 효율적으로 해결된다 (코테/기술면접에서 유용)
- **비트연산 vs 일반 산술 연산**
    - 언어나 CPU 아키텍쳐에 따라 다를수있다
    - 성능의 차이는 보통 비트연산이 약간 빠르나, 쉽게 체감할수 있는 정도는 아니다
    - 하지만, 이 약간의 차이가 임팩트를 가져올수있는 상황에서는 유용할수 있다

#### 이진수 표현

Go 언어를 사용한다고 가정, Go에서 모든 숫자는 내부적으로 이진수로 저장된다

```
십진수 5는 101 -> 8비트 표현시 00000101

십진수 7은 1010 -> 8비트 표현시 00001010
```

10진수는 나눗셈 공식을 사용해서 2진수로 쉽게 표현할수 있음

```
5/2 = 2 나머지는 1 
2/2 = 1 나머지는 0 
1/2 = 0 나머지  1 

역순으로 읽으면 101 
```

```
10/2 = 5 나머지는 0 
5/2 = 2 나머지는 1
2/2 = 1 나머지  0 
1/2 = 0, 나머지 1

역순으로 읽으면 1010 
```

#### Bit Operators

| 연산자         | 기호  | 설명                     | 예시           | 결과   |
| ----------- | --- | ---------------------- | ------------ | ---- |
| AND         | &   | 두 비트 모두 1일 때만 1        | 0101 & 0011  | 0001 |
| OR          | \|  | 둘 중 하나라도 1이면 1         | 0101 \| 0011 | 0111 |
| XOR         | ^   | 두 비트가 다르면 1, 같으면 0     | 0101 ^ 0011  | 0110 |
| Left Shift  | <<  | 비트를 왼쪽으로 이동 (2^n 곱하기)  | 0101 << 1    | 1010 |
| Right Shift | >>  | 비트를 오른쪽으로 이동 (2^n 나누기) | 1000 >> 1    | 0100 |
| NOT         | ~   | 모든 비트를 반전 (1→0, 0→1)   | 0101         | 1010 |

**AND (&):** 비트가 모두 1일때만 결과가 1

```go
var a byte = 5  // 00000101
var b byte = 3  // 00000011

var result byte = a & b  // 결과: 00000001 (1)

fmt.Printf("%08b\n", result)

```

**OR (|):** 비트 중 하나라도 1이면 결과가 1
```go
var a byte = 5  // 00000101
var b byte = 3  // 00000011

var result byte = a | b  // 결과: 00000111 (7)

fmt.Printf("%08b\n", result)
```

**XOR (^):** 비트가 다를 때만 결과가 1
```go
var a byte = 5  // 00000101
var b byte = 3  // 00000011

var result byte = a ^ b  // 결과: 00000110 (6)

fmt.Printf("%08b\n", result)
```

**NOT (~):** 비트를 반전시킨다
```go
//Go 에는 unary operator ~대신 ^연산자 사용 

// byte
var a byte = 5  // 00000101
var result byte = ^a  // 결과: 11111010 (250)

// int
var a int = 5  // 00000000 00000000 00000000 00000101
var result int = ^a  // 결과: 11111111 11111111 11111111 11111010 (-6)


fmt.Printf("%08b\n", result)
fmt.Printf("%d\n", result)

```

- byte(uint8) 타입에서는 부호 비트가 없어서 250이 됨
    - byte(uint8)는 부호가 없는(unsigned) 8비트 정수 타입이기 때문 (0 ~ 255 범위)
- int 타입에서는 부호 비트가 있어서 -6이 됨
    - 정수 n에 대해 NOT 연산(^)의 결과는 -(n+1)


**Left Shifting (<<):** 숫자의 비트를 왼쪽으로 이동시킨다

- 왼쪽으로 이동하면 숫자는 **2의 거듭제곱 배수**로 증가
- 예를 들어, `n << k`는 `n * 2^k`와 동일

```go
var a byte = 5    // 00000101
var result byte = a << 1  // 00001010 (10)

fmt.Printf("%08b\n", result)  // 출력: 00001010
fmt.Println(result)           // 출력: 10
```

**Right Shifting (>>):** 숫자의 비트를 오른쪽으로 이동시킨다

- 오른쪽으로 이동하면 숫자는 **2의 거듭제곱 배수**로 감소
- 예를 들어, `n >> k`는 `n / 2^k`와 동일

```go
var a byte = 10   // 00001010
var result byte = a >> 1  // 00000101 (5)

fmt.Printf("%08b\n", result)  // 출력: 00000101
fmt.Println(result)           // 출력: 5
```


#### 활용 패턴

##### 1. **Bitwise 더하기 (비트 단위 덧셈)**

비트 연산을 사용하여 두 정수의 합을 계산하는 방법. 이 방법은 덧셈을 비트 단위로 처리하며, **자리올림(carry)** 을 고려하여 계산한다.

```go
// 비트 단위 덧셈
func BitwiseAdd(a, b int) int {
    for b != 0 {
        // 자리올림 (carry) 계산
        carry := a & b
        
        // 각 자리의 합 (자리올림을 제외한 합)
        a = a ^ b
        
        // 자리올림을 왼쪽으로 1비트 이동하여 더해줌
        b = carry << 1
    }
    return a
}
```

1. **`a & b`**: 두 수의 각 비트에서 자리올림이 필요한 곳 찾기.
2. **`a ^ b`**: 두 수의 각 비트를 더하고 자리올림은 제외한 결과를 계산
3. **`b = carry << 1`**: 자리올림을 왼쪽으로 1비트 이동시켜서 다음 자리로 이동

이 과정을 반복하여 `b`가 0이 될 때까지 더하는 작업을 계속 수행한다

```go
fmt.Println(BitwiseAdd(5, 3))  // 출력: 8
```

---

##### 2. **절댓값 구하기 (Abs 구하기)**

정수의 절댓값을 구하는 문제


```go
// 절댓값 구하기
func abs(n int) int {
    // n이 음수일 때: ^n + 1 = -n
    // n이 양수일 때: 그대로 n
    mask := n >> 31  // 부호 비트를 전체로 확장
    return (n ^ mask) - mask
}
```

1. **`mask := n >> 31`**: 정수 `n`의 부호 비트를 추출. `n >> 31`은 부호 비트를 최상위 비트로 확장하여 음수일 경우 1, 양수일 경우 0을 반환하게된다.
2. **`n ^ mask`**: `n`과 `mask`를 XOR 연산하면, `n`이 음수일 경우 부호가 반전된다
3. **`(n ^ mask) - mask`**: 만약 음수라면 부호를 반전시킨 후, `-mask`를 빼서 절댓값을 구할수있다

```go
fmt.Println(abs(-5))  // 출력: 5
fmt.Println(abs(5))   // 출력: 5
```

---

##### 3. **홀짝 판별하기**

정수가 홀수인지 짝수인지를 판별하는 방법


```go
// 홀짝 판별하기
n := 7
isOdd := n & 1 != 0
fmt.Printf("%d는 홀수? %v\n", n, isOdd)
```

- **`n & 1`**: 숫자 `n`의 마지막 비트만을 추출.
- 마지막 비트가 `1`이면 홀수, `0`이면 짝수이다.
- **`n & 1 != 0`**: 마지막 비트가 `1`인지 확인하여 홀수인지 짝수인지를 판펼하는 방식

```go
n := 7
isOdd := n & 1 != 0
fmt.Println(isOdd)  // 출력: true (홀수)
```

---

##### 4. **2의 거듭제곱 판별하기**

정수가 2의 거듭제곱인지 판별하는 방법. 2의 거듭제곱은 이진수로 `10000...`와 같이, 단 하나의 `1`만 존재하는 형태를 가진다는 사실을 활용하는 방법


```go
// 2의 거듭제곱 판별하기
isPowerOfTwo := n != 0 && (n & (n-1)) == 0
fmt.Printf("%d는 2의 거듭제곱? %v\n", n, isPowerOfTwo)
```

- **`n & (n - 1)`**: 2의 거듭제곱인 숫자 `n`에서는 `n - 1`과 AND 연산을 하면 0이 됨
    - 예를 들어, `n = 8` (`1000`)일 때 `n - 1 = 7` (`0111`)이고, `n & (n-1)`은 `1000 & 0111`로 `0`이 된다
- **`n != 0`**: 0은 2의 거듭제곱이 아니므로 이를 제외

```go
fmt.Println(2 & (2-1) == 0)  // 출력: true (2는 2의 거듭제곱)
fmt.Println(3 & (3-1) == 0)  // 출력: false (3은 2의 거듭제곱 아님)
```

---

##### 5. **비트 카운팅 (1의 비트 개수 세기)**

주어진 정수에서 `1`이 나타나는 비트의 개수를 세는 방법

```go
func countBits(n int) int {
    count := 0
    for n != 0 {
        count += n & 1  // 마지막 비트가 1이면 count 증가
        n >>= 1  // 오른쪽으로 비트 시프트
    }
    return count
}
```


1. **`n & 1`**: 마지막 비트가 `1`인지를 체크
2. **`n >>= 1`**: 비트를 오른쪽으로 시프트하여 다음 비트를 검사
3. 이 과정을 숫자 `n`이 0이 될 때까지 반복하여, 1의 개수를 카운팅

```go
fmt.Println(countBits(7))  // 출력: 3 (0111에서 1의 개수)
```
